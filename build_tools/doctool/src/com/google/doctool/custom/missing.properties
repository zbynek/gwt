todo.title = Needs implementing
todo.description = These methods can be implemented, code contributions welcome
todo = java.io.ByteArrayOutputStream#toString(Charset)\
java.io.ByteArrayOutputStream#writeBytes(byte[])\
java.util.Map#copyOf(Entry)\
java.util.Objects#checkIndex(long, long)\
java.util.Objects#checkFromIndexSize(long, long, long)\
java.util.Objects#checkFromToIndex(long, long, long)\
java.lang.CharSequence#compare(CharSequence, CharSequence)\
java.lang.CharSequence#isEmpty()\
java.util.Arrays#compare(boolean[], int, int, boolean[], int, int)\
java.util.Arrays#compare(byte[], byte[])\
java.util.Arrays#compare(byte[], int, int, byte[], int, int)\
java.util.Arrays#compare(boolean[], boolean[])\
java.util.Arrays#compare(Object[], int, int, Object[], int, int, Comparator)\
java.util.Arrays#compare(double[], int, int, double[], int, int)\
java.util.Arrays#compare(Comparable[], Comparable[])\
java.util.Arrays#compare(Comparable[], int, int, Comparable[], int, int)\
java.util.Arrays#compare(int[], int, int, int[], int, int)\
java.util.Arrays#compare(Object[], Object[], Comparator)\
java.util.Arrays#compare(int[], int[])\
java.util.Arrays#compare(long[], long[])\
java.util.Arrays#compare(long[], int, int, long[], int, int)\
java.util.Arrays#compare(float[], float[])\
java.util.Arrays#compare(float[], int, int, float[], int, int)\
java.util.Arrays#compare(double[], double[])\
java.util.Arrays#compare(char[], int, int, char[], int, int)\
java.util.Arrays#compare(char[], char[])\
java.util.Arrays#compare(short[], int, int, short[], int, int)\
java.util.Arrays#compare(short[], short[])\
java.util.Arrays#equals(double[], int, int, double[], int, int)\
java.util.Arrays#equals(boolean[], int, int, boolean[], int, int)\
java.util.Arrays#equals(Object[], int, int, Object[], int, int, Comparator)\
java.util.Arrays#equals(Object[], Object[], Comparator)\
java.util.Arrays#equals(Object[], int, int, Object[], int, int)\
java.util.Arrays#equals(float[], int, int, float[], int, int)\
java.util.Arrays#equals(int[], int, int, int[], int, int)\
java.util.Arrays#equals(long[], int, int, long[], int, int)\
java.util.Arrays#equals(byte[], int, int, byte[], int, int)\
java.util.Arrays#equals(char[], int, int, char[], int, int)\
java.util.Arrays#equals(short[], int, int, short[], int, int)\
java.util.Arrays#mismatch(short[], int, int, short[], int, int)\
java.util.Arrays#mismatch(int[], int[])\
java.util.Arrays#mismatch(boolean[], int, int, boolean[], int, int)\
java.util.Arrays#mismatch(long[], int, int, long[], int, int)\
java.util.Arrays#mismatch(long[], long[])\
java.util.Arrays#mismatch(int[], int, int, int[], int, int)\
java.util.Arrays#mismatch(byte[], int, int, byte[], int, int)\
java.util.Arrays#mismatch(boolean[], boolean[])\
java.util.Arrays#mismatch(byte[], byte[])\
java.util.Arrays#mismatch(char[], char[])\
java.util.Arrays#mismatch(char[], int, int, char[], int, int)\
java.util.Arrays#mismatch(short[], short[])\
java.util.Arrays#mismatch(Object[], Object[])\
java.util.Arrays#mismatch(Object[], int, int, Object[], int, int)\
java.util.Arrays#mismatch(Object[], Object[], Comparator)\
java.util.Arrays#mismatch(Object[], int, int, Object[], int, int, Comparator)\
java.util.Arrays#mismatch(float[], float[])\
java.util.Arrays#mismatch(float[], int, int, float[], int, int)\
java.util.Arrays#mismatch(double[], double[])\
java.util.Arrays#mismatch(double[], int, int, double[], int, int)\
java.util.stream.Collectors#teeing(Collector, Collector, BiFunction)\
java.util.stream.DoubleStream#mapMulti(DoubleMapMultiConsumer)\
java.util.stream.IntStream#mapMulti(IntMapMultiConsumer)\
java.util.stream.LongStream#mapMulti(LongMapMultiConsumer)\
java.util.stream.Stream#toList()\
java.util.stream.Stream#mapMulti(BiConsumer)\
java.util.stream.Stream#mapMultiToInt(BiConsumer)\
java.util.stream.Stream#mapMultiToLong(BiConsumer)\
java.util.stream.Stream#mapMultiToDouble(BiConsumer)\
java.lang.Byte#toUnsignedLong(byte)\
java.lang.Byte#toUnsignedInt(byte)\
java.lang.Byte#compareUnsigned(byte, byte)\
java.lang.CharSequence#codePoints()\
java.lang.Integer#toUnsignedLong(int)\
java.lang.Integer#parseInt(CharSequence, int, int, int)\
java.lang.Integer#compareUnsigned(int, int)\
java.lang.Integer#toUnsignedString(int, int)\
java.lang.Integer#toUnsignedString(int)\
java.lang.Integer#parseUnsignedInt(String, int)\
java.lang.Integer#parseUnsignedInt(CharSequence, int, int, int)\
java.lang.Integer#parseUnsignedInt(String)\
java.util.Arrays#compareUnsigned(short[], short[])\
java.util.Arrays#compareUnsigned(byte[], int, int, byte[], int, int)\
java.util.Arrays#compareUnsigned(byte[], byte[])\
java.util.Arrays#compareUnsigned(long[], long[])\
java.util.Arrays#compareUnsigned(int[], int, int, int[], int, int)\
java.util.Arrays#compareUnsigned(long[], int, int, long[], int, int)\
java.util.Arrays#compareUnsigned(short[], int, int, short[], int, int)\
java.util.Arrays#compareUnsigned(int[], int[])\
java.util.BitSet#stream()\
java.util.Collection#toArray(IntFunction)\
java.util.Collections#emptyEnumeration()\
java.util.Collections#indexOfSubList(List, List)\
java.util.Collections#lastIndexOfSubList(List, List)\
java.util.Collections#unmodifiableNavigableSet(NavigableSet)\
java.util.Collections#unmodifiableNavigableMap(NavigableMap)\
java.lang.String#indent(int)\
java.lang.String#stripIndent()\
java.lang.String#translateEscapes()\
java.lang.String#transform(Function)\
java.lang.Integer#divideUnsigned(int, int)\
java.lang.Integer#remainderUnsigned(int, int)\
java.util.Collections#emptySortedSet()\
java.util.Collections#emptyNavigableSet()\
java.util.Collections#emptySortedMap()\
java.util.Collections#emptyNavigableMap()\
java.lang.Short#toUnsignedLong(short)\
java.lang.Short#toUnsignedInt(short)\
java.lang.Short#compareUnsigned(short, short)\
java.lang.StrictMath#decrementExact(int)\
java.lang.StrictMath#decrementExact(long)\
java.lang.StrictMath#incrementExact(int)\
java.lang.StrictMath#incrementExact(long)\
java.lang.StrictMath#negateExact(long)\
java.lang.StrictMath#negateExact(int)\
java.lang.StrictMath#cbrt(double)\
java.lang.StrictMath#nextAfter(double, double)\
java.lang.StrictMath#nextAfter(float, double)\
java.lang.StrictMath#nextUp(float)\
java.lang.StrictMath#nextUp(double)\
java.lang.StrictMath#nextDown(double)\
java.lang.StrictMath#nextDown(float)\
java.lang.StrictMath#abs(long)\
java.io.InputStream#readAllBytes()\
java.io.InputStream#readNBytes(int)\
java.io.InputStream#readNBytes(byte[], int, int)\
java.io.InputStream#transferTo(OutputStream)\
java.io.InputStream#nullInputStream()\
java.io.InputStream#skipNBytes(long)\
java.io.OutputStream#nullOutputStream()\
java.io.PrintStream#writeBytes(byte[])\
java.io.Reader#nullReader()\
java.io.Reader#transferTo(Writer)\
java.io.Writer#nullWriter()

unicode.title = Unicode
unicode.description = These methods cannot be supported without a Unicode database
unicode = java.lang.Character#getName(int)\
java.lang.Character#isJavaIdentifierStart(char)\
java.lang.Character#isJavaIdentifierStart(int)\
java.lang.Character#isJavaIdentifierPart(char)\
java.lang.Character#isJavaIdentifierPart(int)\
java.lang.Character#toString(int)\
java.lang.Character#reverseBytes(char)\
java.lang.Character#isDigit(int)\
java.lang.Character#isLowerCase(int)\
java.lang.Character#isUpperCase(int)\
java.lang.Character#isSurrogate(char)\
java.lang.Character#highSurrogate(int)\
java.lang.Character#lowSurrogate(int)\
java.lang.Character#toLowerCase(int)\
java.lang.Character#toUpperCase(int)\
java.lang.Character#getType(char)\
java.lang.Character#getType(int)\
java.lang.Character#isLetter(int)\
java.lang.Character#isLetterOrDigit(int)\
java.lang.Character#isTitleCase(int)\
java.lang.Character#isDefined(int)\
java.lang.Character#isDefined(char)\
java.lang.Character#isIdeographic(int)\
java.lang.Character#isSpaceChar(int)\
java.lang.Character#isSpaceChar(char)\
java.lang.Character#isUnicodeIdentifierStart(int)\
java.lang.Character#isUnicodeIdentifierStart(char)\
java.lang.Character#isUnicodeIdentifierPart(int)\
java.lang.Character#isUnicodeIdentifierPart(char)\
java.lang.Character#isIdentifierIgnorable(int)\
java.lang.Character#isIdentifierIgnorable(char)\
java.lang.Character#toTitleCase(int)\
java.lang.Character#toTitleCase(char)\
java.lang.Character#digit(int, int)\
java.lang.Character#getNumericValue(int)\
java.lang.Character#getNumericValue(char)\
java.lang.Character#isISOControl(char)\
java.lang.Character#isISOControl(int)\
java.lang.Character#getDirectionality(int)\
java.lang.Character#getDirectionality(char)\
java.lang.Character#isMirrored(char)\
java.lang.Character#isMirrored(int)\
java.lang.Character#isJavaLetter(char)\
java.lang.Character#isAlphabetic(int)\
java.lang.Character#codePointOf(String)

reflection.title = Reflection and metadata
reflection.description = Implementing these methods would require storing class metadata that would increase the build size too much.
reflection = java.lang.StackTraceElement#isNativeMethod()\
java.lang.StackTraceElement#getModuleName()\
java.lang.StackTraceElement#getModuleVersion()\
java.lang.StackTraceElement#getClassLoaderName()\
java.lang.Class#forName(String, boolean, ClassLoader)\
java.lang.Class#forName(String)\
java.lang.Class#forName(Module, String)\
java.lang.Class#getModule()\
java.lang.Class#getProtectionDomain()\
java.lang.Class#isAssignableFrom(Class)\
java.lang.Class#isInstance(Object)\
java.lang.Class#getModifiers()\
java.lang.Class#isHidden()\
java.lang.Class#cast(Object)\
java.lang.Class#isAnnotation()\
java.lang.Class#isRecord()\
java.lang.Class#getClassLoader()\
java.lang.Class#newInstance()\
java.lang.Class#getInterfaces()\
java.lang.Class#getEnclosingClass()\
java.lang.Class#getResourceAsStream(String)\
java.lang.Class#getResource(String)\
java.lang.Class#getPackageName()\
java.lang.Class#getMethod(String, Class[])\
java.lang.Class#getNestHost()\
java.lang.Class#getPermittedSubclasses()\
java.lang.Class#toGenericString()\
java.lang.Class#isSynthetic()\
java.lang.Class#getGenericSuperclass()\
java.lang.Class#getPackage()\
java.lang.Class#getGenericInterfaces()\
java.lang.Class#getSigners()\
java.lang.Class#getEnclosingMethod()\
java.lang.Class#getEnclosingConstructor()\
java.lang.Class#getDeclaringClass()\
java.lang.Class#isAnonymousClass()\
java.lang.Class#isLocalClass()\
java.lang.Class#isMemberClass()\
java.lang.Class#getClasses()\
java.lang.Class#getFields()\
java.lang.Class#getMethods()\
java.lang.Class#getConstructors()\
java.lang.Class#getField(String)\
java.lang.Class#getConstructor(Class[])\
java.lang.Class#getDeclaredClasses()\
java.lang.Class#getDeclaredFields()\
java.lang.Class#getRecordComponents()\
java.lang.Class#getDeclaredMethods()\
java.lang.Class#getDeclaredConstructors()\
java.lang.Class#getDeclaredField(String)\
java.lang.Class#getDeclaredMethod(String, Class[])\
java.lang.Class#getDeclaredConstructor(Class[])\
java.lang.Class#asSubclass(Class)\
java.lang.Class#getAnnotatedSuperclass()\
java.lang.Class#getAnnotatedInterfaces()\
java.lang.Class#isNestmateOf(Class)\
java.lang.Class#getNestMembers()\
java.lang.Class#isSealed()\
java.util.Collections#checkedCollection(Collection, Class)\
java.util.Collections#checkedQueue(Queue, Class)\
java.util.Collections#checkedSet(Set, Class)\
java.util.Collections#checkedSortedSet(SortedSet, Class)\
java.util.Collections#checkedNavigableSet(NavigableSet, Class)\
java.util.Collections#checkedList(List, Class)\
java.util.Collections#checkedMap(Map, Class, Class)\
java.util.Collections#checkedSortedMap(SortedMap, Class, Class)\
java.util.Collections#checkedNavigableMap(NavigableMap, Class, Class)\
java.beans.Beans#getInstanceOf(Object, Class)\
java.beans.Beans#isInstanceOf(Object, Class)\
java.beans.Beans#instantiate(ClassLoader, String, BeanContext, AppletInitializer)\
java.beans.Beans#instantiate(ClassLoader, String)\
java.beans.Beans#instantiate(ClassLoader, String, BeanContext)\
java.lang.reflect.Array#newInstance(Class, int)\
java.lang.reflect.Array#newInstance(Class, int[])\
java.lang.reflect.Type#getTypeName()\
java.util.Arrays#copyOf(Object[], int, Class)\
java.util.Arrays#copyOfRange(Object[], int, int, Class)\
java.io.Externalizable#writeExternal(ObjectOutput)\
java.io.Externalizable#readExternal(ObjectInput)

locale.title = Localization
locale.description = Implementing these methods would require locale info (localized number format, currency etc), increasing the build size too much.
locale = java.io.PrintStream#format(String, Object[])\
java.io.PrintStream#format(Locale, String, Object[])\
java.io.PrintStream#printf(Locale, String, Object[])\
java.io.PrintStream#printf(String, Object[])\
java.lang.String#format(String, Object[])\
java.lang.String#format(Locale, String, Object[])\
java.util.logging.Logger#log(Level, String, Object)\
java.util.logging.Logger#log(Level, String, Object[])\
java.util.logging.Logger#logp(Level, String, String, String, Object)\
java.util.logging.Logger#logp(Level, String, String, Throwable, Supplier)\
java.util.logging.Logger#logp(Level, String, String, String, Throwable)\
java.util.logging.Logger#logp(Level, String, String, String)\
java.util.logging.Logger#logp(Level, String, String, String, Object[])\
java.util.logging.Logger#logp(Level, String, String, Supplier)\
java.util.logging.Logger#logrb(Level, String, String, ResourceBundle, String, Object[])\
java.util.logging.Logger#logrb(Level, ResourceBundle, String, Object[])\
java.util.logging.Logger#logrb(Level, String, String, String, String, Throwable)\
java.util.logging.Logger#logrb(Level, String, String, ResourceBundle, String, Throwable)\
java.util.logging.Logger#logrb(Level, ResourceBundle, String, Throwable)\
java.util.logging.Logger#logrb(Level, String, String, String, String)\
java.util.logging.Logger#logrb(Level, String, String, String, String, Object)\
java.util.logging.Logger#logrb(Level, String, String, String, String, Object[])\
java.util.Locale#clone()\
java.util.Locale#getDefault(Category)\
java.util.Locale#lookup(List, Collection)\
java.util.Locale#filter(List, Collection)\
java.util.Locale#filter(List, Collection, FilteringMode)\
java.util.Locale#getLanguage()\
java.util.Locale#getDisplayName()\
java.util.Locale#getDisplayName(Locale)\
java.util.Locale#getAvailableLocales()\
java.util.Locale#getUnicodeLocaleType(String)\
java.util.Locale#getCountry()\
java.util.Locale#stripExtensions()\
java.util.Locale#hasExtensions()\
java.util.Locale#getVariant()\
java.util.Locale#getScript()\
java.util.Locale#setDefault(Category, Locale)\
java.util.Locale#setDefault(Locale)\
java.util.Locale#getUnicodeLocaleAttributes()\
java.util.Locale#getUnicodeLocaleKeys()\
java.util.Locale#getDisplayLanguage()\
java.util.Locale#getDisplayLanguage(Locale)\
java.util.Locale#getDisplayScript(Locale)\
java.util.Locale#getDisplayScript()\
java.util.Locale#getDisplayCountry()\
java.util.Locale#getDisplayCountry(Locale)\
java.util.Locale#getDisplayVariant()\
java.util.Locale#getDisplayVariant(Locale)\
java.util.Locale#filterTags(List, Collection)\
java.util.Locale#filterTags(List, Collection, FilteringMode)\
java.util.Locale#lookupTag(List, Collection)\
java.util.Locale#getISOCountries(IsoCountryCode)\
java.util.Locale#getISOCountries()\
java.util.Locale#getISOLanguages()\
java.util.Locale#getExtension(char)\
java.util.Locale#getExtensionKeys()\
java.util.Locale#toLanguageTag()\
java.util.Locale#forLanguageTag(String)\
java.util.Locale#getISO3Language()\
java.util.Locale#getISO3Country()\
java.nio.charset.Charset#displayName(Locale)\
java.lang.String#formatted(Object[])

threads.title = Threads
threads.description = These are not possible to implement because JS is single-threaded.
threads = java.util.concurrent.Executors#newFixedThreadPool(int)\
java.util.concurrent.Executors#newFixedThreadPool(int, ThreadFactory)\
java.util.concurrent.Executors#newSingleThreadExecutor(ThreadFactory)\
java.util.concurrent.Executors#newSingleThreadExecutor()\
java.util.concurrent.Executors#newCachedThreadPool(ThreadFactory)\
java.util.concurrent.Executors#newCachedThreadPool()\
java.util.concurrent.Executors#newSingleThreadScheduledExecutor(ThreadFactory)\
java.util.concurrent.Executors#newSingleThreadScheduledExecutor()\
java.util.concurrent.Executors#newScheduledThreadPool(int, ThreadFactory)\
java.util.concurrent.Executors#newScheduledThreadPool(int)\
java.util.concurrent.Executors#defaultThreadFactory()\
java.util.concurrent.Executors#privilegedThreadFactory()\
java.util.logging.LogRecord#getThreadID()\
java.util.logging.LogRecord#setThreadID(int)\
java.util.logging.LogRecord#getLongThreadID()\
java.util.logging.LogRecord#setLongThreadID(long)\
java.util.concurrent.TimeUnit#timedJoin(Thread, long)\
java.util.concurrent.ExecutorService#awaitTermination(long, TimeUnit)

concurrent.title = Concurrent APIs
concurrent.description = These methods can be implemented in principle, but do not bring much value since JS is single-threaded and concurrency issues cannot happen.
concurrent = java.util.concurrent.ConcurrentHashMap#forEach(long, BiConsumer)\
java.util.concurrent.ConcurrentHashMap#forEach(long, BiFunction, Consumer)\
java.util.concurrent.ConcurrentHashMap#keySet(Object)\
java.util.concurrent.ConcurrentHashMap#mappingCount()\
java.util.concurrent.ConcurrentHashMap#newKeySet(int)\
java.util.concurrent.ConcurrentHashMap#search(long, BiFunction)\
java.util.concurrent.ConcurrentHashMap#reduce(long, BiFunction, BiFunction)\
java.util.concurrent.ConcurrentHashMap#reduceToDouble(long, ToDoubleBiFunction, double, DoubleBinaryOperator)\
java.util.concurrent.ConcurrentHashMap#reduceToLong(long, ToLongBiFunction, long, LongBinaryOperator)\
java.util.concurrent.ConcurrentHashMap#reduceToInt(long, ToIntBiFunction, int, IntBinaryOperator)\
java.util.concurrent.ConcurrentHashMap#forEachKey(long, Consumer)\
java.util.concurrent.ConcurrentHashMap#forEachKey(long, Function, Consumer)\
java.util.concurrent.ConcurrentHashMap#searchKeys(long, Function)\
java.util.concurrent.ConcurrentHashMap#reduceKeys(long, BiFunction)\
java.util.concurrent.ConcurrentHashMap#reduceKeys(long, Function, BiFunction)\
java.util.concurrent.ConcurrentHashMap#reduceKeysToDouble(long, ToDoubleFunction, double, DoubleBinaryOperator)\
java.util.concurrent.ConcurrentHashMap#reduceKeysToLong(long, ToLongFunction, long, LongBinaryOperator)\
java.util.concurrent.ConcurrentHashMap#reduceKeysToInt(long, ToIntFunction, int, IntBinaryOperator)\
java.util.concurrent.ConcurrentHashMap#forEachValue(long, Function, Consumer)\
java.util.concurrent.ConcurrentHashMap#forEachValue(long, Consumer)\
java.util.concurrent.ConcurrentHashMap#searchValues(long, Function)\
java.util.concurrent.ConcurrentHashMap#reduceValues(long, BiFunction)\
java.util.concurrent.ConcurrentHashMap#reduceValues(long, Function, BiFunction)\
java.util.concurrent.ConcurrentHashMap#reduceValuesToDouble(long, ToDoubleFunction, double, DoubleBinaryOperator)\
java.util.concurrent.ConcurrentHashMap#reduceValuesToLong(long, ToLongFunction, long, LongBinaryOperator)\
java.util.concurrent.ConcurrentHashMap#reduceValuesToInt(long, ToIntFunction, int, IntBinaryOperator)\
java.util.concurrent.ConcurrentHashMap#forEachEntry(long, Consumer)\
java.util.concurrent.ConcurrentHashMap#forEachEntry(long, Function, Consumer)\
java.util.concurrent.ConcurrentHashMap#searchEntries(long, Function)\
java.util.concurrent.ConcurrentHashMap#reduceEntries(long, BiFunction)\
java.util.concurrent.ConcurrentHashMap#reduceEntries(long, Function, BiFunction)\
java.util.concurrent.ConcurrentHashMap#reduceEntriesToDouble(long, ToDoubleFunction, double, DoubleBinaryOperator)\
java.util.concurrent.ConcurrentHashMap#reduceEntriesToLong(long, ToLongFunction, long, LongBinaryOperator)\
java.util.concurrent.ConcurrentHashMap#reduceEntriesToInt(long, ToIntFunction, int, IntBinaryOperator)\
java.util.concurrent.Executors#newWorkStealingPool()\
java.util.concurrent.Executors#newWorkStealingPool(int)\
java.util.concurrent.Executors#unconfigurableExecutorService(ExecutorService)\
java.util.concurrent.Executors#unconfigurableScheduledExecutorService(ScheduledExecutorService)\
java.util.concurrent.Executors#privilegedCallable(Callable)\
java.util.concurrent.Executors#privilegedCallableUsingCurrentClassLoader(Callable)\
java.util.concurrent.Executors#callable(PrivilegedAction)\
java.util.concurrent.Executors#callable(PrivilegedExceptionAction)\
java.util.concurrent.atomic.AtomicBoolean#getOpaque()\
java.util.concurrent.atomic.AtomicBoolean#setOpaque(boolean)\
java.util.concurrent.atomic.AtomicBoolean#getAcquire()\
java.util.concurrent.atomic.AtomicBoolean#setRelease(boolean)\
java.util.concurrent.atomic.AtomicBoolean#compareAndExchange(boolean, boolean)\
java.util.concurrent.atomic.AtomicBoolean#compareAndExchangeAcquire(boolean, boolean)\
java.util.concurrent.atomic.AtomicBoolean#compareAndExchangeRelease(boolean, boolean)\
java.util.concurrent.atomic.AtomicBoolean#weakCompareAndSetPlain(boolean, boolean)\
java.util.concurrent.atomic.AtomicBoolean#weakCompareAndSetAcquire(boolean, boolean)\
java.util.concurrent.atomic.AtomicBoolean#weakCompareAndSetRelease(boolean, boolean)\
java.util.concurrent.atomic.AtomicBoolean#weakCompareAndSetVolatile(boolean, boolean)\
java.util.concurrent.atomic.AtomicBoolean#getPlain()\
java.util.concurrent.atomic.AtomicBoolean#setPlain(boolean)\
java.util.concurrent.atomic.AtomicInteger#getOpaque()\
java.util.concurrent.atomic.AtomicInteger#setOpaque(int)\
java.util.concurrent.atomic.AtomicInteger#getAcquire()\
java.util.concurrent.atomic.AtomicInteger#setRelease(int)\
java.util.concurrent.atomic.AtomicInteger#compareAndExchange(int, int)\
java.util.concurrent.atomic.AtomicInteger#compareAndExchangeAcquire(int, int)\
java.util.concurrent.atomic.AtomicInteger#compareAndExchangeRelease(int, int)\
java.util.concurrent.atomic.AtomicInteger#weakCompareAndSetPlain(int, int)\
java.util.concurrent.atomic.AtomicInteger#weakCompareAndSet(int, int)\
java.util.concurrent.atomic.AtomicInteger#weakCompareAndSetAcquire(int, int)\
java.util.concurrent.atomic.AtomicInteger#weakCompareAndSetRelease(int, int)\
java.util.concurrent.atomic.AtomicInteger#weakCompareAndSetVolatile(int, int)\
java.util.concurrent.atomic.AtomicInteger#getAndUpdate(IntUnaryOperator)\
java.util.concurrent.atomic.AtomicInteger#updateAndGet(IntUnaryOperator)\
java.util.concurrent.atomic.AtomicInteger#getAndAccumulate(int, IntBinaryOperator)\
java.util.concurrent.atomic.AtomicInteger#accumulateAndGet(int, IntBinaryOperator)\
java.util.concurrent.atomic.AtomicInteger#getPlain()\
java.util.concurrent.atomic.AtomicInteger#setPlain(int)\
java.util.concurrent.atomic.AtomicLong#getOpaque()\
java.util.concurrent.atomic.AtomicLong#setOpaque(long)\
java.util.concurrent.atomic.AtomicLong#getAcquire()\
java.util.concurrent.atomic.AtomicLong#setRelease(long)\
java.util.concurrent.atomic.AtomicLong#compareAndExchange(long, long)\
java.util.concurrent.atomic.AtomicLong#compareAndExchangeAcquire(long, long)\
java.util.concurrent.atomic.AtomicLong#compareAndExchangeRelease(long, long)\
java.util.concurrent.atomic.AtomicLong#weakCompareAndSetPlain(long, long)\
java.util.concurrent.atomic.AtomicLong#weakCompareAndSet(long, long)\
java.util.concurrent.atomic.AtomicLong#weakCompareAndSetAcquire(long, long)\
java.util.concurrent.atomic.AtomicLong#weakCompareAndSetRelease(long, long)\
java.util.concurrent.atomic.AtomicLong#weakCompareAndSetVolatile(long, long)\
java.util.concurrent.atomic.AtomicLong#getAndUpdate(LongUnaryOperator)\
java.util.concurrent.atomic.AtomicLong#updateAndGet(LongUnaryOperator)\
java.util.concurrent.atomic.AtomicLong#getAndAccumulate(long, LongBinaryOperator)\
java.util.concurrent.atomic.AtomicLong#accumulateAndGet(long, LongBinaryOperator)\
java.util.concurrent.atomic.AtomicLong#getPlain()\
java.util.concurrent.atomic.AtomicLong#setPlain(long)\
java.util.concurrent.atomic.AtomicReference#getOpaque()\
java.util.concurrent.atomic.AtomicReference#setOpaque(Object)\
java.util.concurrent.atomic.AtomicReference#getAcquire()\
java.util.concurrent.atomic.AtomicReference#setRelease(Object)\
java.util.concurrent.atomic.AtomicReference#compareAndExchange(Object, Object)\
java.util.concurrent.atomic.AtomicReference#compareAndExchangeAcquire(Object, Object)\
java.util.concurrent.atomic.AtomicReference#compareAndExchangeRelease(Object, Object)\
java.util.concurrent.atomic.AtomicReference#weakCompareAndSetPlain(Object, Object)\
java.util.concurrent.atomic.AtomicReference#weakCompareAndSetAcquire(Object, Object)\
java.util.concurrent.atomic.AtomicReference#weakCompareAndSetRelease(Object, Object)\
java.util.concurrent.atomic.AtomicReference#weakCompareAndSetVolatile(Object, Object)\
java.util.concurrent.atomic.AtomicReference#getAndUpdate(UnaryOperator)\
java.util.concurrent.atomic.AtomicReference#updateAndGet(UnaryOperator)\
java.util.concurrent.atomic.AtomicReference#getAndAccumulate(Object, BinaryOperator)\
java.util.concurrent.atomic.AtomicReference#accumulateAndGet(Object, BinaryOperator)\
java.util.concurrent.atomic.AtomicReference#getPlain()\
java.util.concurrent.atomic.AtomicReference#setPlain(Object)\
java.util.concurrent.atomic.AtomicReferenceArray#getOpaque(int)\
java.util.concurrent.atomic.AtomicReferenceArray#setOpaque(int, Object)\
java.util.concurrent.atomic.AtomicReferenceArray#getAcquire(int)\
java.util.concurrent.atomic.AtomicReferenceArray#setRelease(int, Object)\
java.util.concurrent.atomic.AtomicReferenceArray#compareAndExchange(int, Object, Object)\
java.util.concurrent.atomic.AtomicReferenceArray#compareAndExchangeAcquire(int, Object, Object)\
java.util.concurrent.atomic.AtomicReferenceArray#compareAndExchangeRelease(int, Object, Object)\
java.util.concurrent.atomic.AtomicReferenceArray#weakCompareAndSetPlain(int, Object, Object)\
java.util.concurrent.atomic.AtomicReferenceArray#weakCompareAndSetAcquire(int, Object, Object)\
java.util.concurrent.atomic.AtomicReferenceArray#weakCompareAndSetRelease(int, Object, Object)\
java.util.concurrent.atomic.AtomicReferenceArray#weakCompareAndSetVolatile(int, Object, Object)\
java.util.concurrent.atomic.AtomicReferenceArray#getAndUpdate(int, UnaryOperator)\
java.util.concurrent.atomic.AtomicReferenceArray#updateAndGet(int, UnaryOperator)\
java.util.concurrent.atomic.AtomicReferenceArray#getAndAccumulate(int, Object, BinaryOperator)\
java.util.concurrent.atomic.AtomicReferenceArray#accumulateAndGet(int, Object, BinaryOperator)\
java.util.concurrent.atomic.AtomicReferenceArray#getPlain(int)\
java.util.concurrent.atomic.AtomicReferenceArray#setPlain(int, Object)\
java.util.stream.Collectors#groupingByConcurrent(Function, Collector)\
java.util.stream.Collectors#groupingByConcurrent(Function, Supplier, Collector)\
java.util.stream.Collectors#groupingByConcurrent(Function)\
java.util.stream.Collectors#toConcurrentMap(Function, Function)\
java.util.stream.Collectors#toConcurrentMap(Function, Function, BinaryOperator, Supplier)\
java.util.stream.Collectors#toConcurrentMap(Function, Function, BinaryOperator)\

time.title = Time
time.description = Advanced time APIs require time zone information and are out of scope for GWT. Third party implementations may help.
time = java.util.concurrent.TimeUnit#convert(Duration)\
java.util.concurrent.TimeUnit#of(ChronoUnit)\
java.util.concurrent.TimeUnit#sleep(long)\
java.util.concurrent.TimeUnit#timedWait(Object, long)\
java.util.concurrent.TimeUnit#toChronoUnit()\
java.util.logging.LogRecord#getInstant()\
java.util.logging.LogRecord#setInstant(Instant)\
java.sql.Date#valueOf(LocalDate)\
java.sql.Date#toLocalDate()\
java.sql.Time#valueOf(LocalTime)\
java.sql.Time#toLocalTime()\
java.sql.Timestamp#valueOf(LocalDateTime)\
java.sql.Timestamp#toLocalDateTime()\
java.util.Date#from(Instant)\
java.util.Date#toInstant()

sandbox.title = Access to system resources
sandbox.description = These methods cannot be implemented because they require access to system resources (filesystem, terminal etc.)
sandbox = java.lang.System#getenv(String)\
java.lang.System#getenv()\
java.lang.System#getLogger(String, ResourceBundle)\
java.util.logging.LogRecord#getResourceBundleName()\
java.util.logging.LogRecord#setResourceBundleName(String)\
java.util.logging.LogRecord#setResourceBundle(ResourceBundle)\
java.util.logging.LogRecord#getResourceBundle()\
java.lang.System#exit(int)\
java.lang.System#runFinalization()\
java.lang.System#load(String)\
java.lang.System#getSecurityManager()\
java.lang.System#loadLibrary(String)\
java.lang.System#console()\
java.lang.System#inheritedChannel()\
java.lang.System#setSecurityManager(SecurityManager)\
java.beans.Beans#isGuiAvailable()\
java.beans.Beans#setDesignTime(boolean)\
java.beans.Beans#setGuiAvailable(boolean)\
java.security.MessageDigest#getInstance(String, String)\
java.security.MessageDigest#getInstance(String, Provider)\
java.lang.System#setIn(InputStream)\
java.lang.System#mapLibraryName(String)

properties.title = Properties
properties.description = GWT and Java have different semantics for properties.
properties = java.lang.Integer#getInteger(String, Integer)\
java.lang.Integer#getInteger(String)\
java.lang.Integer#getInteger(String, int)\
java.lang.Long#getLong(String, long)\
java.lang.Long#getLong(String)\
java.lang.Long#getLong(String, Long)\
java.lang.Boolean#getBoolean(String)\
java.lang.System#getProperties()\
java.lang.System#setProperties(Properties)\
java.lang.System#setProperty(String, String)\
java.lang.System#clearProperty(String)

long.title = Emulation of long
long.description = These methods could be implemented together with improved Long support
long = java.lang.Long#compareUnsigned(long, long)\
java.lang.Long#toUnsignedString(long, int)\
java.lang.Long#toUnsignedString(long)\
java.lang.Long#parseLong(CharSequence, int, int, int)\
java.lang.Long#divideUnsigned(long, long)\
java.lang.Long#remainderUnsigned(long, long)\
java.lang.Long#parseUnsignedLong(String, int)\
java.lang.Long#parseUnsignedLong(CharSequence, int, int, int)\
java.lang.Long#parseUnsignedLong(String)\
java.lang.Math#multiplyExact(long, int)\
java.lang.Math#multiplyHigh(long, long)\
java.lang.Math#absExact(long)\
java.lang.StrictMath#multiplyExact(long, int)\
java.lang.StrictMath#multiplyHigh(long, long)\
java.lang.StrictMath#floorMod(long, int)\
java.lang.Math#floorMod(long, int)\
java.lang.StrictMath#floorDiv(long, int)\
java.lang.StrictMath#absExact(long)\
java.lang.Math#floorDiv(long, int)

bigint.title = BigInteger and BigDecimal emulation
bigint.description = These methods could be improved as part of BigInteger implementation based on native BigInt
bigint = java.lang.StrictMath#fma(float, float, float)\
java.lang.StrictMath#fma(double, double, double)\
java.lang.Math#fma(double, double, double)\
java.lang.Math#fma(float, float, float)\
java.math.BigDecimal#sqrt(MathContext)\
java.math.BigInteger#sqrt()\
java.math.BigInteger#sqrtAndRemainder()

undecided.title = Undecided
undecided.description = It is unclear whether implementing these should be considered
undecided = java.lang.Deprecated#since()\
java.lang.Deprecated#forRemoval()\
java.lang.Double#doubleToRawLongBits(double)\
java.lang.Double#toHexString(double)\
java.lang.Float#floatToRawIntBits(float)\
java.lang.Float#toHexString(float)\
java.lang.Math#getExponent(float)\
java.lang.Math#getExponent(double)\
java.lang.Math#IEEEremainder(double, double)\
java.lang.Math#multiplyFull(int, int)\
java.lang.Math#absExact(int)\
java.lang.Math#ulp(double)\
java.lang.Math#ulp(float)\
java.lang.StrictMath#getExponent(float)\
java.lang.StrictMath#getExponent(double)\
java.lang.StrictMath#IEEEremainder(double, double)\
java.lang.StrictMath#multiplyFull(int, int)\
java.lang.StrictMath#absExact(int)\
java.lang.StrictMath#ulp(double)\
java.lang.StrictMath#ulp(float)\
java.lang.System#lineSeparator()\
java.lang.System#getLogger(String)\
java.lang.Throwable#printStackTrace(PrintWriter)\
java.lang.annotation.AnnotationTypeMismatchException#foundType()\
java.lang.annotation.AnnotationTypeMismatchException#element()\
java.security.MessageDigest#getProvider()\
java.security.MessageDigestSpi#clone()\
java.util.EnumSet#of(Enum, Enum, Enum)\
java.util.EnumSet#of(Enum, Enum)\
java.util.EnumSet#of(Enum, Enum, Enum, Enum)\
java.util.EnumSet#of(Enum, Enum, Enum, Enum, Enum)\
java.util.TreeMap#clone()\
java.util.TreeSet#clone()

nio.title = java.nio package
nio.description = Support for java.nio classes is out of scope for GWT, but you can find third party implementations.
nio = java.security.MessageDigest#update(ByteBuffer)\
java.util.BitSet#valueOf(ByteBuffer)\
java.util.BitSet#valueOf(LongBuffer)\
java.nio.charset.Charset#newDecoder()\
java.nio.charset.Charset#newEncoder()\
java.nio.charset.Charset#encode(String)\
java.nio.charset.Charset#decode(ByteBuffer)\
java.nio.charset.Charset#encode(CharBuffer)\
java.nio.charset.Charset#canEncode()\
java.nio.charset.Charset#contains(Charset)\
java.nio.charset.Charset#isRegistered()\
java.nio.charset.Charset#aliases()\
java.nio.charset.Charset#isSupported(String)\
java.nio.charset.Charset#displayName()

logging.title = Logging
logging.description = Many logging features are not useful in the browser.
logging = java.util.logging.Formatter#getHead(Handler)\
java.util.logging.Formatter#getTail(Handler)\
java.util.logging.Handler#getEncoding()\
java.util.logging.Handler#getFilter()\
java.util.logging.Handler#setEncoding(String)\
java.util.logging.Handler#setFilter(Filter)\
java.util.logging.Handler#setErrorManager(ErrorManager)\
java.util.logging.Handler#getErrorManager()\
java.util.logging.Level#getResourceBundleName()\
java.util.logging.Level#getLocalizedName()\
java.util.logging.LogManager#getProperty(String)\
java.util.logging.LogManager#checkAccess()\
java.util.logging.LogManager#reset()\
java.util.logging.LogManager#readConfiguration(InputStream)\
java.util.logging.LogManager#readConfiguration()\
java.util.logging.LogManager#updateConfiguration(Function)\
java.util.logging.LogManager#updateConfiguration(InputStream, Function)\
java.util.logging.LogManager#getLoggingMXBean()\
java.util.logging.LogManager#addConfigurationListener(Runnable)\
java.util.logging.LogManager#removeConfigurationListener(Runnable)\
java.util.logging.LogRecord#getSequenceNumber()\
java.util.logging.LogRecord#setSequenceNumber(long)\
java.util.logging.LogRecord#getSourceClassName()\
java.util.logging.LogRecord#getSourceMethodName()\
java.util.logging.LogRecord#getParameters()\
java.util.logging.LogRecord#setParameters(Object[])\
java.util.logging.LogRecord#setSourceClassName(String)\
java.util.logging.LogRecord#setSourceMethodName(String)\
java.util.logging.Logger#getLogger(String, String)\
java.util.logging.Logger#getFilter()\
java.util.logging.Logger#setFilter(Filter)\
java.util.logging.Logger#getResourceBundleName()\
java.util.logging.Logger#getAnonymousLogger(String)\
java.util.logging.Logger#getAnonymousLogger()\
java.util.logging.Logger#setResourceBundle(ResourceBundle)\
java.util.logging.Logger#getResourceBundle()\
java.util.logging.Logger#entering(String, String, Object)\
java.util.logging.Logger#entering(String, String)\
java.util.logging.Logger#entering(String, String, Object[])\
java.util.logging.Logger#exiting(String, String, Object)\
java.util.logging.Logger#exiting(String, String)\
java.util.logging.Logger#throwing(String, String, Throwable)

deprecated.title = Deprecated
deprecated.description = Methods deprecated in Java won't be emulated.
deprecated=java.lang.Character#isJavaLetter(char)\
java.lang.Character#isJavaLetterOrDigit(char)\
java.lang.String#getBytes(int, int, byte[], int)


